{"meta":{"title":"Aiden's Blog","subtitle":"Record Everthing","description":"","author":"AidenLee","url":"http://Bulabula-Reeves.github.io","root":"/"},"pages":[{"title":"","date":"2024-06-29T13:28:54.551Z","updated":"2023-08-26T10:06:51.960Z","comments":true,"path":"404.html","permalink":"http://bulabula-reeves.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2024-06-29T13:28:54.553Z","updated":"2023-08-27T15:26:26.596Z","comments":true,"path":"categories/index.html","permalink":"http://bulabula-reeves.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-06-29T13:28:54.553Z","updated":"2023-08-27T15:26:39.220Z","comments":true,"path":"tags/index.html","permalink":"http://bulabula-reeves.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"测试","date":"2024-06-29T13:38:32.826Z","updated":"2024-06-29T13:39:06.665Z","comments":true,"path":"2024/06/29/测试/","link":"","permalink":"http://bulabula-reeves.github.io/2024/06/29/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"TEST BLOG","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-06-29T13:28:54.554Z","updated":"2023-04-19T04:09:38.050Z","comments":true,"path":"2024/06/29/hello-world/","link":"","permalink":"http://bulabula-reeves.github.io/2024/06/29/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"遗传算法","slug":"遗传算法","date":"2020-03-02T16:00:00.000Z","updated":"2024-07-14T14:03:09.116Z","comments":true,"path":"2020/03/03/遗传算法/","link":"","permalink":"http://bulabula-reeves.github.io/2020/03/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/","excerpt":"妙哉","text":"妙哉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from mpl_toolkits.mplot3d import Axes3Dfrom matplotlib import cmimport numpy as npimport matplotlib.pyplot as pltDNA_SIZE = 24POP_SIZE = 200CROSSOVER_RATE = 0.8MUTATION_RATE = 0.005N_GENERATIONS = 50X_BOUND = [-3, 3]Y_BOUND = [-3, 3]def F(x, y): return 3 * (1 - x) ** 2 * np.exp(-(x ** 2) - (y + 1) ** 2) - 10 * (x / 5 - x ** 3 - y ** 5) * np.exp( -x ** 2 - y ** 2) - 1 / 3 ** np.exp(-(x + 1) ** 2 - y ** 2)def plot_3d(ax): X = np.linspace(*X_BOUND, 100) Y = np.linspace(*Y_BOUND, 100) X, Y = np.meshgrid(X, Y) Z = F(X, Y) ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm) ax.set_zlim(-10, 10) ax.set_xlabel(&#x27;x&#x27;) ax.set_ylabel(&#x27;y&#x27;) ax.set_zlabel(&#x27;z&#x27;) plt.pause(3) plt.show()def get_fitness(pop): x, y = translateDNA(pop) pred = F(x, y) return (pred - np.min(pred))+ 1e-3 # 减去最小的适应度是为了防止适应度出现负数，通过这一步fitness的范围为[0, np.max(pred)-np.min(pred)]def translateDNA(pop): # pop表示种群矩阵，一行表示一个二进制编码表示的DNA，矩阵的行数为种群数目 x_pop = pop[:, 1::2] # 奇数列表示X,从索引列1开始，加入了步长2 y_pop = pop[:, ::2] # 偶数列表示y,从索引列1开始，加入了步长2 # pop:(POP_SIZE,DNA_SIZE)*(DNA_SIZE,1) --&gt; (POP_SIZE,1) x = x_pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (X_BOUND[1] - X_BOUND[0]) + X_BOUND[0] y = y_pop.dot(2 ** np.arange(DNA_SIZE)[::-1]) / float(2 ** DNA_SIZE - 1) * (Y_BOUND[1] - Y_BOUND[0]) + Y_BOUND[0] return x, ydef crossover_and_mutation(pop, CROSSOVER_RATE=0.8): new_pop = [] for father in pop: # 遍历种群中的每一个个体，将该个体作为父亲 child = father # 孩子先得到父亲的全部基因（这里我把一串二进制串的那些0，1称为基因） if np.random.rand() &lt; CROSSOVER_RATE: # 产生子代时不是必然发生交叉，而是以一定的概率发生交叉 mother = pop[np.random.randint(POP_SIZE)] # 再种群中选择另一个个体，并将该个体作为母亲 cross_points = np.random.randint(low=0, high=DNA_SIZE * 2) # 随机产生交叉的点 child[cross_points:] = mother[cross_points:] # 孩子得到位于交叉点后的母亲的基因 mutation(child) # 每个后代有一定的机率发生变异 new_pop.append(child) return new_popdef mutation(child, MUTATION_RATE=0.003): if np.random.rand() &lt; MUTATION_RATE: # 以MUTATION_RATE的概率进行变异 mutate_point = np.random.randint(0, DNA_SIZE * 2) # 随机产生一个实数，代表要变异基因的位置 child[mutate_point] = child[mutate_point] ^ 1 # 将变异点的二进制为反转def select(pop, fitness): # nature selection wrt pop&#x27;s fitness idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=(fitness) / (fitness.sum())) return pop[idx]def print_info(pop): fitness = get_fitness(pop) max_fitness_index = np.argmax(fitness) print(&quot;max_fitness:&quot;, fitness[max_fitness_index]) x, y = translateDNA(pop) print(&quot;最优的基因型：&quot;, pop[max_fitness_index]) print(&quot;(x, y):&quot;, (x[max_fitness_index], y[max_fitness_index])) print(&quot;Z:&quot;, F(x[max_fitness_index], y[max_fitness_index]))if __name__ == &quot;__main__&quot;: fig = plt.figure() ax = Axes3D(fig) plt.ion() # 将画图模式改为交互模式，程序遇到plt.show不会暂停，而是继续执行 plot_3d(ax) pop = np.random.randint(2, size=(POP_SIZE, DNA_SIZE * 2)) # matrix (POP_SIZE, DNA_SIZE) for _ in range(N_GENERATIONS): # 迭代N代 x, y = translateDNA(pop) if &#x27;sca&#x27; in locals(): sca.remove() sca = ax.scatter(x, y, F(x, y), c=&#x27;black&#x27;, marker=&#x27;o&#x27;) plt.show() plt.pause(0.1) pop = np.array(crossover_and_mutation(pop, CROSSOVER_RATE)) # F_values = F(translateDNA(pop)[0], translateDNA(pop)[1])#x, y --&gt; Z matrix fitness = get_fitness(pop) pop = select(pop, fitness) # 选择生成新的种群 print_info(pop) plt.ioff() plot_3d(ax) 遗传算法有时候只能逼近最优解，那么有什么方法能让他达到更好的逼近效果呢？ 这里有几个方案： 使用自适应遗传和变异概率增加种群中个体数量增大迭代次数使用双点交叉法采用多样的变异方法更改编码方式（某些情况）更换适应度函数，将个体适应度的差距拉大更换选择方法，轮盘赌法是最基本的方法，不科学","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://bulabula-reeves.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://bulabula-reeves.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://bulabula-reeves.github.io/tags/tag2/"}],"author":"Aiden"},{"title":"力与运动（MathJax）","slug":"物理教案","date":"2020-02-22T16:00:00.000Z","updated":"2023-08-19T15:09:31.674Z","comments":true,"path":"2020/02/23/物理教案/","link":"","permalink":"http://bulabula-reeves.github.io/2020/02/23/%E7%89%A9%E7%90%86%E6%95%99%E6%A1%88/","excerpt":"","text":"力与运动匀速直线运动公式 速度公式 位移公式 位移、速度关系公式 $v_t&#x3D;v_0+at $ $x&#x3D;v_0t+\\frac{1}{2}at^2$ $v_t^2-v_0^2&#x3D;2ax$ $\\Delta x&#x3D;at^2$ 匀直运动任意两个连续相等的时间段内位移之差是一个恒量 $ \\bar{v}&#x3D;v_{\\frac{t}{2}}&#x3D;\\frac{v_0+v_t}{2} $ 某时间段内的平均速度，等于该时间段的中间时刻的瞬时速度 $ v_{\\frac{x}{2}}&#x3D;\\sqrt{\\frac{v_0^2+v_t^2}{2}}$ 某段位移中点的瞬时速度 $ x_1:x_2:x_3:…&#x3D;1^2:2^2:3^2:…$ t内、2t内、3t内……位移之比 $ v_1:v_2:v_3:…&#x3D;1:2:3:…$ t末、2t末、3t末……速度之比 $ x_1:x_2:x_3:…&#x3D;1:3:5:…$ 第一个t内，第二个t内，第三个t内……位移之比 $ t_1:t_2:t_3:…&#x3D;1:(\\sqrt2 -1):(\\sqrt3 -\\sqrt2):…$ 从静止开始通过连续相等的位移所用时间之比 平衡力学 重力 弹簧弹力 滑动摩擦力 $G&#x3D;mg$ $F&#x3D;kx$ $f&#x3D;\\mu F_n$ 力的合成中我们可以用到余弦定理求得非特殊情况的合力大小及方向：$F&#x3D;\\sqrt{F_1^2+F_2^2+2F_1F_2cos\\theta }$ , $tan\\alpha &#x3D;\\frac{F_2sin\\theta}{F_1+F_2cos\\theta}$ 牛顿第二定律 $F&#x3D;ma$ 圆周运动 线速度 角速度 周期和转速 向心加速度 向心力 $v&#x3D;\\frac{\\Delta l}{\\Delta t}&#x3D;\\frac{2\\pi r}{T}$ $\\omega&#x3D;\\frac{\\Delta \\theta}{\\Delta t}&#x3D;\\frac{2\\pi }{T}$ $T&#x3D;\\frac{2 \\pi r}{v}$,$f&#x3D;\\frac{1}{T}$ $a&#x3D;\\frac{v^2}{r}&#x3D;r\\omega^2$ $F_n&#x3D;m\\frac{v^2}{r}&#x3D;m\\omega^2r&#x3D;mv\\omega$ 天体运动 开普勒第三定律 万有引力公式 黄金代换公式（忽略地球自转时才可应用） $ \\frac{a^3}{T^2}&#x3D;k$ $F&#x3D;G\\frac{m_1m_2}{r^2}$ 由$mg&#x3D;\\frac{GMm}{R^2}$推导得到$GM&#x3D;R^2g$ 机械能 平均功率 瞬时功率 $\\bar{P}&#x3D;\\frac{W}{t}$ $P&#x3D;Fvcos\\alpha$ $\\bar{P}&#x3D;F\\bar{v}cos\\alpha$ $P&#x3D;Fv$ 动能 重力势能 $E_k&#x3D;\\frac{1}{2}mv^2$ $E_p&#x3D;mgh$ 动量定理 动量 冲量 $p&#x3D;mv$ $I&#x3D;F\\Delta t$ 第一章 运动学（匀速直线运动）公式：1、基本公式 2、若干推论以及推导记忆过程 3、时间中点速度总小于位移中点速度 核心：1、质点、参考系的理解 2、位移、路程的区别 3、矢量标量的区别 4、匀直运动的求解方法：运用图像以及随时注意物理量是标量还是矢量 5、知三求二思想 6、类比思想：自由落体运动、竖直上抛运动总结 题型：1、八大求解方法（思想） 2、实际运动学基本的三类问题（贯彻类比定方法的思想） 实验：第二章 平衡力学（相互作用）公式：1、基本公式 核心：1、重力、重心、弹力基本概念。注意重心不一定在物体上，弹力的产生条件判断受力，弹力大小 2、静摩擦和滑动摩擦力的对比以及注意事项 3、静摩擦力判断的三种方法，摩擦力突变的四种类型 4、弹力有无判断的三种方法 5、摩擦力大小的计算及注意事项 6、力的合成分解基本概念，合成分解的大小范围分析，常用的两种分解方法原则 7、矢量的可分解思想 题型：实验：第三章 牛顿运动定律（牛二力学）公式：1、基本公式 核心：题型：实验：第四章 曲线运动（曲线、天体）公式：核心：题型：实验：第五章 机械能公式：核心：题型：实验：第六章 碰撞与动量守恒定律公式：核心：题型：实验：电学第一章 静电场第二章 欧姆定律第三章 磁场第四章 电磁感应第五章 交变电流选修部分：机械波选修部分：光学选修部分：热学与近代物理","categories":[],"tags":[]}],"categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://bulabula-reeves.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"}],"tags":[{"name":"tag1","slug":"tag1","permalink":"http://bulabula-reeves.github.io/tags/tag1/"},{"name":"tag2","slug":"tag2","permalink":"http://bulabula-reeves.github.io/tags/tag2/"}]}